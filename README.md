# Demo

This project demonstrates how to use [Red Hat AMQ](https://www.redhat.com/en/technologies/jboss-middleware/amq) + [Red Hat Data Grid](https://www.redhat.com/en/technologies/jboss-middleware/data-grid) and [Red Hat Build of Camel with Quarkus](https://access.redhat.com/documentation/en-us/red_hat_build_of_apache_camel_extensions_for_quarkus/) to create a data layer with a canonical data model.

<p align="center">
  <img src="diagram.png" alt="Diagram"/>
</p>

Below is a description of each component of the solution:

* **camel-amq-datagrid-common:**
  * Contains the canonical model of the data that will be available in the Data Grid. 
  * This project is shared between Camel transformation routes and Data Grid customers.
* **Transformation layer** 
  * **app1-camel-amq-datagrid**:
    * Responsible for receiving notifications about events generated by *app1* in the queue _APP1_DATA_RECORD_QUEUE_ and update the data in the Data Grid.
    * The route converts the model data known only by _App1_ in **json** format to the canonical model defined in camel-amq-datagrid-common.
    * Monitors topic _CACHE_UPDATE_REQUEST_ for cache refresh request. Triggers a REST API of the service *app1* requesting to add updated data to the message queue _APP1_DATA_RECORD_QUEUE_
  * **app2-camel-amq-datagrid**:
    * Responsible for receiving notifications about events generated by *app2* in the queue _APP2_DATA_RECORD_QUEUE_ and update the data in the Data Grid.
    * The route converts the model data known only by _App2_ in **xml** format to the canonical model defined in camel-amq-datagrid-common.
    * Monitors topic _CACHE_UPDATE_REQUEST_ for cache refresh request. Triggers a REST API of the service *app2* requesting to add updated data to the message queue _APP2_DATA_RECORD_QUEUE_
* **Access layer**
  * **front-rest-cache-client**:
    * Demonstrates how to consume data directly from the Data Grid and expose it through a REST API and an HTML interface. If the record is not found in the Data Grid, the application publishes a message in the _CACHE_UPDATE_REQUEST_ topic requesting that the applications publish data about the record in the AMQ MESSAGE BROKER and thus the Data Grid is updated.
    * Demonstrates how to configure and consume a Data Grid event listener to update the GUI in real time using [Server-Sent Events (SSE)](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
  * **camel-rest-cache**:
    * Exposes the record query through a REST API simplifying access for clients that don't need to deal with connectivity to the Data Grid.
    * If the record is not found in the Data Grid, the application publishes a message in the _CACHE_UPDATE_REQUEST_ topic requesting that the applications publish data about the record in the AMQ MESSAGE BROKER and thus the Data Grid is updated.
  * **nodejs-rest-client**:
    * A simple client that consumes the API published by the _camel-rest-cache_ service and displays it through an HTML interface.
* **Producer layer**
  * **app1**: 
    * Represents an application with its particular data model. Publishes data changes to the _APP1_DATA_RECORD_QUEUE_ queue and receives notifications via REST API from _app1-camel-amq-datagrid_ camel route to provide data.
  * **app2**:
    * Represents an application with its particular data model. Publishes data changes to the _APP2_DATA_RECORD_QUEUE_ queue and receives notifications via REST API from _app2-camel-amq-datagrid_ camel route to provide data.

## Requirements
* JDK 17+
* Docker runtime 24+
* Docker Compose 2.19+
* NPM 9.5+
* Node 18+

> **Note**
> The examples below were run on a MacOS Ventura 13.4.1

> **Warning**
> Before running the commands below, check your platform configuration to support the above requirements.

## Run Separate

### Compile all projects
```shell
./mvnw clean install -DskipTests
```

### Start the infra services
```shell
docker compose down && docker compose up
```

### Execute the Generator client (a fake source)
```shell
cd amq-client
./mvnw quarkus:dev -Ddebug=false
```

### Execute the First Integration layer
```shell
cd app1-camel-amq-datagrid
./mvnw quarkus:dev -Ddebug=false

cd app2-camel-amq-datagrid
./mvnw quarkus:dev -Ddebug=false
```

### Execute the second Integration layer
```shell
cd camel-rest-cache
./mvnw quarkus:dev -Ddebug=false
```

### Execute a custom app that can connect with datagrid and amq
```shell
cd front-rest-cache-client
./mvnw quarkus:dev -Ddebug=false
```

### Execute the view client for camel-rest-cache
```shell
cd nodejs-rest-client
npm install
node server.js
```

---

## Run with Docker compose

### Compile all projects
```shell
./mvnw clean install -Dskiptests
```

### Execute all projects
```shell
docker compose -f docker-compose-complete.yml down && docker compose -f docker-compose-complete.yml up --build
```

## Testing the solution

> **Note**
> Before running the tests it is necessary that all services are properly active, use the way you want above.

1. Access the _front-rest-cache-client_ service web interface `http://localhost:8090`
![](img01.png)
2. Access the _Data Grid_ admin console and navigate to the cache DATA-LAYER-CACHE page `http://localhost:11222/console/cache/DATA-LAYER-CACHE`
![](img02.png)
> **Warning**
> At first, the cache will be completely empty. In a productive environment it is necessary to decide if this is the expected behavior or if auxiliary services will be necessary to "warm up" the cache before the applications look for information in it.

> **Note**
> In this solution, the applications look for the registration key in the cache and if they don't find it, they start a process to populate the cache. In the case of the _front-rest-cache-client_ application, which is configured to listen to events from the Data Grid and has the capacity to receive events from the server, the interface is updated in real time.

3. Access the _front-nodejs-rest-client_ service web interface `http://localhost:3000`. *The interface is exactly the same as the **front-rest-cache-client** service*
![](img01.png)

4. In the _front-rest-cache-client_ interface, look for record **1**. Naturally, this value will not be found in the cache, so the service will send an update request by publishing a message in topic _CACHE_UPDATE_REQUEST_ in the AMQ Broker. 
> **Note** 
> We are talking about a **topic** and not a **queue**, as this update request must be answered by all applications that supply data to the canonical Data Grid model.

5. The first response will be something similar to the snippet below, indicating that an update process for the requested record has been initiated.
```json
{
    "type": "LOAD",
    "registry": null,
    "message": "Data will be loaded, please wait a few seconds"
}
```

6. A few seconds later, you will be able to see the interface update with a sample of randomly generated data
![](img03.png)

> **Note**
> In a real environment this data would possibly come from a database, for the sake of simplicity, both _app1_ and _app2_ make use of templates to generate examples with random data.


